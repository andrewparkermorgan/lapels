#! /bin/env python 
'''
Created on Sep 30, 2012

@author: Shunping Huang
'''

import os
import sys
import gc
import pysam
import argparse as ap

from modtools.mod2 import Mod
from modtools import tmpmod

from lapels.matefixer import *
from lapels.utils import *
#from lapels import annotator2 as annotator
import lapels.version


DESC = 'A remapper and annotator of in silico (pseudo) genome alignments.'
VERBOSITY = 1
VERSION = lapels.version.__version__



def validTagPrefix(s):
    if len(s) != 1:
        msg = "Tag Prefix '%s' should have exactly one character." % s
        raise ap.ArgumentTypeError(msg)
    
    if (s == 'X' or s == 'Y' or s== 'Z' or s[0].islower()):
        return s
    else:
        msg = "Tag Prefix '%s' is not valid/reserved for local use." % s
        raise ap.ArgumentTypeError(msg)



if __name__ == '__main__':
    ## Parse arguments
    p = ap.ArgumentParser(description=DESC, 
                          formatter_class = ap.RawTextHelpFormatter)
    group = p.add_mutually_exclusive_group()    
    group.add_argument("-q", dest='quiet', action='store_true',
                       help='quiet mode')  
    group.add_argument('-v', dest='verbosity', action="store_const", const=2,
                       default=1, help='verbose mode')
#    p.add_argument('-a', metavar='aliasFile', dest='alias', 
#                   type=readableFile, default = None,
#                   help='the file of chromosome name alias definition' +
#                        ' (default: none)')       
    p.add_argument('-c', metavar='chromList', dest='chroms', 
                   type=validChromList, default = set(),
                   help='a comma-separated list of chromosomes (default: all)')
    p.add_argument('--engine', metavar='id', dest='engine', 
                   type=int, default='5', choices=range(1, 6), 
                   help='engine id (1-5) (default: 5)')
    p.add_argument('--ts', metavar='prefix', type=validTagPrefix, default='s',
                   help='tag prefix for numbers of observed SNPs (default: s)')
    p.add_argument('--ti', metavar='prefix', type=validTagPrefix, default='i',
                   help='tag prefix for numbers of bases in observed insertions'
                        +' (default: i)')
    p.add_argument('--td', metavar='prefix', type=validTagPrefix, default='d',
                   help='tag prefix for numbers of bases in observed deletions' 
                        +' (default: d)')
#    p.add_argument('--tc', metavar='tag', type=validTag, default='OC',
#                   help='tag for the old cigar' +
#                        ' (default: OC)')
#    p.add_argument('--tm', metavar='tag', type=validTag, default='OM',
#                   help='tag for the old NM tag' +
#                        ' (default: OM)')   
    p.add_argument('inMod', metavar='in.mod', type=readableFile, 
                   help='the mod file of the in silico genome')
    p.add_argument('inBam', metavar='in.bam', type=readableFile,
                   help='the input bam file')
    p.add_argument('outBam', metavar='out.bam', nargs = '?', type=writableFile, 
                   default=None, help='the output bam file'\
                        +' (default: input.annotated.bam)')
#    p.add_argument('log', nargs = '?', type=argparse.FileType('w'), 
#                   default=sys.stdout, help='the log file (default: stdout)')
    args = p.parse_args()

    
    if args.quiet:
        VERBOSITY = 0
    else:            
        VERBOSITY = args.verbosity
    
    if args.engine == 1:
        print('annotator1')
        from lapels import annotator as annotator
    elif args.engine == 2:
        print('annotator2')
        from lapels import annotator2 as annotator
    elif args.engine == 3:  
        print('annotator3')      
        from lapels import annotator3 as annotator
    elif args.engine == 4:
        print('annotator4')
        from lapels import annotator4 as annotator
    elif args.engine == 5:
        print('annotator5')
        from lapels import annotator5 as annotator
    
    annotator.VERBOSITY = VERBOSITY
    
    # A compromise: adding complexity but reducing unnecessary argument.
    if VERBOSITY > 0:
        log("extracting MOD file ...\n", 1, True)
    tmpmod = tmpmod.getTabixMod(args.inMod)
    mod = Mod(tmpmod)
        
    chroms = args.chroms    
    if len(args.chroms) == 0: 
        chroms = mod.chroms
    
    chromAliases = mod.meta.chromAliases
            
    tagPrefixes = [args.ts, args.ti, args.td]
            
    if args.outBam is None:        
        if not args.inBam.endswith('.bam'):
            outFileName = args.inBam + '.annotated.bam'
        else:
            outFileName = args.inBam.replace('.bam','.annotated.bam')
    else:
        outFileName = args.outBam
            
#    if args.alias is None:        
#        chromAliases = alias.chromAliases
#    else:
#        chromAliases = alias.Alias()
#        chromAliases.readFromFile(args.alias)
                            
    if VERBOSITY > 0:
        log("input MOD file: %s (%s)\n" % (args.inMod, mod.fileName), 1, True)        
        log("input BAM file: %s\n" % args.inBam, 1, True)         
        log("output BAM file: %s\n" % outFileName, 1, True)
                
    ## Check if bam index exists.
    if not os.path.isfile(args.inBam+'.bai'):
        if VERBOSITY > 0:
            log("creating bam index for input\n", 1, True)
        pysam.index(args.inBam)
        if os.path.isfile(args.inBam+'.bai'):    
            if VERBOSITY > 0:
                log("index created\n", 1, True)
        else:
            if VERBOSITY > 0:
                    log("index failed\n", 1, True)
            raise IOError("Unable to create the bam index. " + 
                          "Make sure the bam file is sorted by coordinate.")

    ## Get the number of reads in each chromosome
    nReadsInChroms = dict()
    for idxstat in pysam.idxstats(args.inBam):        
        tup = idxstat.rstrip('\n').split('\t')
        nReadsInChroms[tup[0]] = int(tup[2])
    
            
    inFile = pysam.Samfile(args.inBam, 'rb')
    outHeader = dict(inFile.header.items())
    
    ## Append a PG tag in the header
    try:    
        outHeader['PG'] = [{'ID': 'Lapels', 'VN': VERSION, 
                            'PP': outHeader['PG'][0]['ID'],                              
                            'CL': ' '.join(sys.argv)}] + outHeader['PG']
    except KeyError:
        ## If there is no 'PG' tag, add a new one
        outHeader['PG'] = [{'ID': 'Lapels', 'VN': VERSION, 
                            'CL': ' '.join(sys.argv)}]
    
    ## Correct reference lengths in the bam header.
    for chrDict in outHeader['SQ']:
        sn = chrDict['SN']
        chrDict['LN'] = mod.meta.getChromLength(sn)
        if chrDict['LN'] is None:
            raise ValueError("Unable to find the length of %s in bam." % 
                             chrDict['SN'])                            

    ##The output bam file will be sorted by position.
    outHeader['HD']['SO'] = 'coordinate'

    #comment = generateComment()
    #outHeader['CO'] = [comment] + outHeader.get('CO',[])    
        
    outPrefix = outFileName[:outFileName.rindex('.bam')]
    tmpFile=pysam.Samfile(outPrefix+'.unsorted.tmp.bam', 'wb', header=outHeader, 
                          referencenames=inFile.references)
    
    
    for outChrom in chroms:
        gc.disable()
        
        if VERBOSITY > 0:
            log("processing chromosome '%s'\n" % outChrom, 1, True)         
        chrom = chromAliases.getBasicName(outChrom)
        
        modChrom = chromAliases.getMatchedAlias(chrom, mod.chroms)
        if modChrom is None:
            if VERBOSITY > 0:
                log("chromosome alias not found for '%s' in MOD\n" % outChrom, 1, True) 
            modChrom = chrom
        else:
            if VERBOSITY > 0:
                log("chromosome alias '%s' used for '%s' in MOD\n" % 
                    (modChrom, outChrom), 1, True)      
        mod.load(modChrom)

        if VERBOSITY > 0:
            log("%d line(s) found in MOD\n" % len(mod.data), 1, True)
            if len(mod.data) == 0:
                log("Warning: chromosome '%s' not found in MOD, " % outChrom + 
                    "maybe incorrect name or mapping\n" 
                    , 2, True)
                
        
        bamChrom = chromAliases.getMatchedAlias(chrom, nReadsInChroms.keys())
        if bamChrom is None:
            raise ValueError("Unable to determine the name of '%s' in BAM." 
                             % outChrom)
        else:
            if VERBOSITY > 0:
                log("chromosome alias '%s' used for '%s' in BAM\n" % 
                    (bamChrom, outChrom), 1, True)
            bamIter = inFile.fetch(bamChrom)
            nReads = nReadsInChroms[bamChrom]
            
        if VERBOSITY > 0:
            log("%d read(s) found\n" % nReads, 1, True)
            
        a = annotator.Annotator(modChrom, mod.meta.getChromLength(chrom), mod, 
                                bamIter, nReads, tagPrefixes, tmpFile)            
        count = a.execute()        
        
        if VERBOSITY > 0:
            log("%d read(s) written to output\n" % count, 1, True)        
        gc.enable()        
    
    inFile.close()
    tmpFile.close()
    
    
    ## Sort by read name, required by fixmate
    if VERBOSITY > 0:
        log("sorting output by read name\n", 1, True)    
    pysam.sort('-n', outPrefix+'.unsorted.tmp.bam', outPrefix+'.sorted.tmp')
    os.remove(outPrefix+'.unsorted.tmp.bam')    

    ## Fix mates
    if VERBOSITY > 0:
        log("fixing mate\n", 1, True)    
    #pysam.fixmate(outPrefix+'.sorted.tmp.bam', outPrefix+'.matefixed.tmp.bam')
    fixmate(outPrefix+'.sorted.tmp.bam', outPrefix+'.matefixed.tmp.bam')
#    os.remove(outPrefix+'.sorted.tmp.bam')    
    
    ## Sort by position
    if VERBOSITY > 0:
        log("sorting output by position\n", 1, True)
    pysam.sort(outPrefix+'.matefixed.tmp.bam', outPrefix)    
#    os.remove(outPrefix+'.matefixed.tmp.bam')
    
    ## Build the bam index for output    
    if VERBOSITY > 0:
        log("creating bam index for final output\n", 1, True)
    pysam.index(outFileName)
    if os.path.isfile(outFileName+'.bai'):    
        if VERBOSITY > 0:
            log("index created\n", 1, True)
    else:
        if VERBOSITY > 0:
                log("index failed\n", 1, True)
        raise IOError("Unable to create the bam index. " + 
                      "Make sure the bam file is sorted by coordinate.")            

    os.remove(mod.fileName)
    os.remove(mod.fileName+'.tbi')
    
    if VERBOSITY > 0:
        log("All Done!\n", 1, True)