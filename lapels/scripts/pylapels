#! /bin/env python 
'''
Created on Sep 30, 2012

@author: Shunping Huang
'''

import os
import sys
import gc
import pysam
import argparse as ap
import logging

from modtools.mod2 import Mod
from modtools import tmpmod

from lapels.matefixer import *
from lapels.utils import readableFile, writableFile, validChromList
from lapels import annotator5 as annotator
import lapels.version


logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
formatter = logging.Formatter("[%(asctime)s] %(name)-10s: %(levelname)s: %(message)s",
                              "%Y-%m-%d %H:%M:%S")
ch.setFormatter(formatter)
logger.addHandler(ch)

DESC = "A remapper and annotator of in silico (pseudo) genome alignments."
VERBOSITY = 1
VERSION = lapels.version.__version__


def validTagPrefix(s):
    if len(s) != 1:
        msg = "Tag Prefix '%s' should have exactly one character." % s
        raise ap.ArgumentTypeError(msg)
    
    if (s == 'X' or s == 'Y' or s== 'Z' or s[0].islower()):
        return s
    else:
        msg = "Tag Prefix '%s' is not valid/reserved for local use." % s
        raise ap.ArgumentTypeError(msg)



if __name__ == '__main__':
    ## Parse arguments
    p = ap.ArgumentParser(description=DESC, 
                          formatter_class = ap.RawTextHelpFormatter)
    group = p.add_mutually_exclusive_group()    
    group.add_argument("-q", dest='quiet', action='store_true',
                       help='quiet mode')  
    group.add_argument('-v', dest='verbosity', action="store_const", const=2,
                       default=1, help='verbose mode')
#    p.add_argument('-a', metavar='aliasFile', dest='alias', 
#                   type=readableFile, default = None,
#                   help='the file of chromosome name alias definition' +
#                        ' (default: none)')       
    p.add_argument('-c', metavar='chromList', dest='chroms', 
                   type=validChromList, default = set(),
                   help='a comma-separated list of chromosomes (default: all)')
#    p.add_argument('--engine', metavar='id', dest='engine', 
#                   type=int, default='5', choices=range(1, 6), 
#                   help='engine id (1-5) (default: 5)')
    p.add_argument('--ts', metavar='prefix', type=validTagPrefix, default='s',
                   help='tag prefix for numbers of observed SNPs (default: s)')
    p.add_argument('--ti', metavar='prefix', type=validTagPrefix, default='i',
                   help='tag prefix for numbers of bases in observed insertions'
                        +' (default: i)')
    p.add_argument('--td', metavar='prefix', type=validTagPrefix, default='d',
                   help='tag prefix for numbers of bases in observed deletions' 
                        +' (default: d)')
#    p.add_argument('--tc', metavar='tag', type=validTag, default='OC',
#                   help='tag for the old cigar' +
#                        ' (default: OC)')
#    p.add_argument('--tm', metavar='tag', type=validTag, default='OM',
#                   help='tag for the old NM tag' +
#                        ' (default: OM)')   
    p.add_argument('inMod', metavar='in.mod', type=readableFile, 
                   help='the mod file of the in silico genome')
    p.add_argument('inBam', metavar='in.bam', type=readableFile,
                   help='the input bam file')
    p.add_argument('outBam', metavar='out.bam', nargs = '?', type=writableFile, 
                   default=None, help='the output bam file'\
                        +' (default: input.annotated.bam)')
#    p.add_argument('log', nargs = '?', type=argparse.FileType('w'), 
#                   default=sys.stdout, help='the log file (default: stdout)')
    args = p.parse_args()

    
    if args.quiet:                
        logger.setLevel(logging.CRITICAL)
    elif args.verbosity == 2:                    
        logger.setLevel(logging.DEBUG)
    
#    if args.engine == 1:
#        print('annotator1')
#        from lapels import annotator as annotator
#    elif args.engine == 2:
#        print('annotator2')
#        from lapels import annotator2 as annotator
#    elif args.engine == 3:  
#        print('annotator3')      
#        from lapels import annotator3 as annotator
#    elif args.engine == 4:
#        print('annotator4')
#        from lapels import annotator4 as annotator
#    elif args.engine == 5:
#        print('annotator5')
#        from lapels import annotator5 as annotator
    
    annotator.VERBOSITY = VERBOSITY
            
    ## Check if bam index exists.
    if not os.path.isfile(args.inBam+'.bai'):        
        logger.info("creating index for input BAM file")
        pysam.index(args.inBam)
        if os.path.isfile(args.inBam+'.bai'):                
            logger.info("index created")
        else:
            logger.exception("index failed")
            raise IOError("Failed to create index. " +
                          "Please make sure the bam file is sorted by position.")
        
    if args.outBam is None:        
        if not args.inBam.endswith('.bam'):
            outFileName = args.inBam + '.annotated.bam'
        else:
            outFileName = args.inBam.replace('.bam','.annotated.bam')
    else:
        outFileName = args.outBam
    
    tagPrefixes = [args.ts, args.ti, args.td]
        
    logger.info("input MOD file: %s", args.inMod)
    logger.info("input BAM file: %s" % args.inBam)
    logger.info("output BAM file: %s" % outFileName)
            
    # A compromise: adding complexity but reducing unnecessary argument.    
    tmpmod = tmpmod.getTabixMod(args.inMod)
    
    mod = Mod(tmpmod)
    chromAliases = mod.meta.chromAliases
        
    chroms = args.chroms    
    if len(args.chroms) == 0: 
        chroms = mod.chroms
                
    ## Get the number of reads in each chromosome
    nReadsInChroms = dict()
    for idxstat in pysam.idxstats(args.inBam):        
        tup = idxstat.rstrip('\n').split('\t')
        nReadsInChroms[tup[0]] = int(tup[2])
            
    inFile = pysam.Samfile(args.inBam, 'rb')
    outHeader = dict(inFile.header.items())
    
    ## Append a PG tag in the header
    try:    
        outHeader['PG'] = [{'ID': 'Lapels', 'VN': VERSION,
                            'PP': outHeader['PG'][0]['ID'],
                            'CL': ' '.join(sys.argv)}] + outHeader['PG']
    except KeyError:
        ## If there is no 'PG' tag, add a new one
        outHeader['PG'] = [{'ID': 'Lapels', 'VN': VERSION, 
                            'CL': ' '.join(sys.argv)}]
    
    ## Correct reference lengths in the bam header.
    for chrDict in outHeader['SQ']:
        sn = chrDict['SN']
        chrDict['LN'] = mod.meta.getChromLength(sn)
        if chrDict['LN'] is None:
            raise ValueError("Unable to find the length of %s in bam." % 
                             chrDict['SN'])                            

    ##The output bam file will be sorted by position.
    outHeader['HD']['SO'] = 'coordinate'

    #comment = generateComment()
    #outHeader['CO'] = [comment] + outHeader.get('CO',[])    
    
    mergePool = []
    outPrefix = outFileName[:outFileName.rindex('.bam')]    
    for outChrom in chroms:        
        gc.disable()
                
        logger.info("processing chromosome '%s'", outChrom)         
        chrom = chromAliases.getBasicName(outChrom)
        
        modChrom = chromAliases.getMatchedAlias(chrom, mod.chroms)
        if modChrom is None:            
            logger.info("alias not found for '%s' in MOD", outChrom) 
            modChrom = str(chrom)
        else:            
            logger.info("alias '%s' used for '%s' in MOD", modChrom, outChrom)              
        
        mod.load(modChrom)                
                
        bamChrom = chromAliases.getMatchedAlias(chrom, nReadsInChroms.keys())
        if bamChrom is None:
            raise ValueError("Unable to determine the name of '%s' in BAM." 
                             % outChrom)
        else:            
            logger.info("alias '%s' used for '%s' in BAM", bamChrom, outChrom)
            bamIter = inFile.fetch(bamChrom)
            nReads = nReadsInChroms[bamChrom]                    
        
        unsortedFileName = "%s.%s.unsorted.bam" % (outPrefix, outChrom)
        tmpFile=pysam.Samfile(unsortedFileName, 'wb', header=outHeader, 
                              referencenames=inFile.references)
                
        a = annotator.Annotator(modChrom, mod.meta.getChromLength(chrom), mod, 
                                bamIter, nReads, tagPrefixes, tmpFile)
        count = a.execute()
        tmpFile.close()
        
        # Sort by read name, required by fixmate
        logger.info("sorting reads by name ...")
        sortedFileName = unsortedFileName.replace('unsorted','sorted')        
        pysam.sort('-n', unsortedFileName, sortedFileName[:-4])
        os.remove(unsortedFileName)
        mergePool.append(sortedFileName)            
        gc.enable()
            
    inFile.close()
            
    # Merge
    logger.info("merging ...")
    mergeParams = ['-f','-n', outPrefix + '.merged.bam'] + mergePool 
    pysam.merge(*mergeParams)
#    for fn in mergePool:
#        os.remove(fn)
    
    # Fix mates
    logger.info("fixing mate ...")    
#    pysam.fixmate(outPrefix+'.sorted.tmp.bam', outPrefix+'.matefixed.tmp.bam')
    fixmate(outPrefix+'.merged.bam', outPrefix+'.matefixed.bam')
#    os.remove(outPrefix+'.sorted.tmp.bam')    
    
    # Sort by position
    logger.info("sorting reads by position ...")
    pysam.sort(outPrefix+'.matefixed.bam', outPrefix)    
#    os.remove(outPrefix+'.matefixed.tmp.bam')
    
    # Build index for output    
    logger.info("creating bam index for final output")
    pysam.index(outFileName)
    if os.path.isfile(outFileName+'.bai'):    
        logger.info("index created")
    else:
        logger.warning("index failed")        

    os.remove(mod.fileName)
    os.remove(mod.fileName+'.tbi')
    
    logger.info("All Done!")
    logging.shutdown()