#! /bin/env python 
'''
Created on Oct 28, 2012

@author: Shunping Huang
'''

import csv
import gc
import pysam
import argparse

from modtools import vcfreader as vcf
from modtools.variants import parseVariant, SUB, INS, DEL
from modtools.utils import buildChromMap, getOutChrom, log

DESC = 'A VCF to MOD converter.'
__version__ = '0.0.2'
VERBOSITY = 1
                

#infiles = ["../../data/indels.chr1_2.vcf.gz", "../../data/snps.chr1_2.vcf.gz"]
#outfile = "./test.mod"
#ref = 'mm9'
#sample = 'A_J'
#chroms = []


def csvChromList(s):    
    chroms = set()
    for chrom in s.split(','):
        chroms.add(chrom)            
    return sorted(chroms)


if __name__ == '__main__':    
    ## Parse arguments
    p = argparse.ArgumentParser(description=DESC, 
                                formatter_class = argparse.RawTextHelpFormatter)
    group = p.add_mutually_exclusive_group()    
    group.add_argument("-q", dest='quiet', action='store_true',
                        help='quiet mode')
    group.add_argument('-v', dest='verbosity', action="store_const", const=2,
                        default=1, help='verbose mode')                    
    p.add_argument('-c', metavar='chromList', dest='chroms', type=csvChromList,
                   default = set(),
                   help='a comma-separated list of chromosomes in VCF' +
                        ' (default: all)')
    p.add_argument('--map', metavar='chromMap', dest='mapfp', type=argparse.FileType('r'),
                   default = None,
                   help='the file of chromosome name mapping from VCF to MOD' +
                        ' (default: none)')
    p.add_argument('-o', metavar='mod', dest='modfp', type=argparse.FileType('w'), 
                   default=None, help='the output mod file'\
                        +' (default: <sample>.mod)')
    
    p.add_argument('ref', help='reference name')
    p.add_argument('sample', help='requested sample name in VCF')
    p.add_argument('infiles', metavar='vcf', nargs='+', 
                   type=argparse.FileType('r'), help='input VCF file(s)')                    
        
    args = p.parse_args()
    
    if args.modfp is None:                
        outfile = args.sample + '.mod'            
        modfp = open(outfile, 'wb')
    else:
        outfile = args.mod.name
        modfp = args.modfp
    
    chromMap = buildChromMap(args.mapfp)
                        
    chroms = args.chroms
    sample = args.sample
    ref = args.ref
            
    if args.quiet:
        VERBOSITY = 0
    else:            
        VERBOSITY = args.verbosity
     
    infiles = args.infiles           
    nFiles = len(infiles)
    for i in range(nFiles):
        infiles[i].close()

    if VERBOSITY > 0:
        log("from %s to %s\n" %(ref, sample), 1 ,True)
        log("input VCF file(s): %s\n" % 
            ', '.join([infiles[i].name for i in range(nFiles)]), 
            1, True)                
        log("output MOD file: %s\n" % outfile, 1, True)
        
    vcfs = [vcf.VCFReader(infiles[i].name, [sample]) for i in range(nFiles)]            
    out = csv.writer(modfp, delimiter='\t',lineterminator='\n')
    
    if len(chroms) == 0:
        allChroms = set()
        for i in range(nFiles):            
            allChroms |= set(vcfs[i].chroms)        
        chroms = sorted(allChroms)   
    
    modfp.write("#ver=0.1\n")
    modfp.write("#ref=%s\n" % ref)
    modfp.write("#sample=%s\n" % sample)
    for chrom in chroms:  # for each chromosome        
        gc.disable()
        pool = []
        modChrom = getOutChrom(chromMap, chrom)
        for i in range(nFiles): # for each VCF file
            count = 0
            if chrom in vcfs[i].chroms:                                        
                if VERBOSITY > 0:
                    log("processing chromosome %s in %s\n" % 
                        (chrom, vcfs[i].fileName), 1, True)                                                                
                for tup in vcfs[i].fetch(chrom):                                                                            
                    v = parseVariant(modChrom, tup[1], tup[2], tup[3])
                    if v.type == SUB:
                        pool.append(('s', modChrom, v.start[1], v.extra))                
                    elif v.type == INS:
                        pool.append(('i', modChrom, v.start[1], v.extra))             
                    elif v.type == DEL:
                        # Change non-atomic deletions to atomic
                        for j in range(v.length):
                            pool.append(('d', modChrom, v.start[1]+j, v.extra[j]))                                         
                    else:
                        raise ValueError("Unknown variant type: %s" % v.type)                        
                    count += 1
                if VERBOSITY > 0:
                    log("%d variants found in %s\n" % 
                        (count, vcfs[i].fileName), 1, True)
            else:
                if VERBOSITY > 0:
                    log("Warning: chromosome %s not found in %s\n" % 
                        (chrom, vcfs[i].fileName), 2, True)
                            
        pool=sorted(set(pool), key = lambda tup: tup[2])            
        out.writerows(pool)
        if VERBOSITY > 0:
            log("%d unique atomic variants written to MOD\n" % len(pool), 1, True)
        del pool
        gc.enable()                        
                    
    
    modfp.close()
    
    if VERBOSITY > 0:
        log("building tabix index for MOD\n", 1, True)
    pysam.tabix_index(outfile, force=True, seq_col=1, start_col=2, end_col=2, 
                      meta_char='#', zerobased=True)
    
    if VERBOSITY > 0:
        log("All Done!\n", 1, True)